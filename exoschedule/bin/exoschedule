#! /usr/bin/python3
# -*- coding: utf-8 -*-

"""
Example

    exoschedule -t0 2025-02-17T00:00:00 -t1 2025-02-24T00:00:00 -b /Users/aloh/Documents/Work/NenuFAR/LT02_Exoplanets/Weekly_Schedule/TESTS/2025-02-14_booking.csv -o /Users/aloh/Documents/Work/NenuFAR/LT02_Exoplanets/Weekly_Schedule/TESTS/
    exoschedule -t0 2025-07-22T00:00:00 -t1 2025-07-29T00:00:00 -n 2 -b /Users/aloh/Documents/Work/NenuFAR/LT02_Exoplanets/Weekly_Schedule/TESTS/2025_july_week4/2025-07-21_booking.csv -o /Users/aloh/Documents/Work/NenuFAR/LT02_Exoplanets/Weekly_Schedule/TESTS/2025_july_week4/ -u

    # if the booking file is already in output (-o)
    exoschedule -t0 2025-09-30T00:00:00 -t1 2025-10-07T01:00:00 -n 2 -o /Users/aloh/Documents/Work/NenuFAR/LT02_Exoplanets/Weekly_Schedule/2025/2025-10-1/ -u

    # Adding imaging
    exoschedule -t0 2025-11-25T00:00:00 -t1 2025-12-02T00:00:00 -n 2 -i -o /Users/aloh/Documents/Work/NenuFAR/LT02_Exoplanets/Weekly_Schedule/2025/2025-11-4_test -u


"""

__author__ = "Alan Loh"
__copyright__ = "Copyright 2025, exoschedule"
__credits__ = ["Alan Loh"]
__maintainer__ = "Alan"
__email__ = "alan.loh@obspm.fr"
__status__ = "Production"
__all__ = [
    "parse_arguments"
]

import argparse
from astropy.time import Time
import glob, os
import logging
log = logging.getLogger("exoschedule")

from exoschedule.functions import (
    bookings_from_vcr,
    booking_difference,
    write_booking_file,
    get_exoplanet_dict,
    get_star_dict,
    update_exposure_time,
    update_minimal_elevation,
    get_imaging_sources
)
from exoschedule.schedule import (
    build_observation_blocks,
    book_observations,
    plot_schedule,
    write_parset_file,
    build_imaging_observation_blocks
)
from exoschedule import DATA_REPOSITORIES, IMAGING_MIN_DURATION, IMAGING_SOURCES


# ============================================================= #
# ---------------------- argument_parser ---------------------- #
def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-t0", "--time_min", type=str, required=True,
        help="Start time (UTC, ISOT format)."
    )
    parser.add_argument(
        "-t1", "--time_max", type=str, required=False,
        help="Stop time (UTC, ISOT format). If not user-defined, will be set to t0 + 7 days."
    )
    # parser.add_argument(
    #     "-u", "--update_data", type=bool, required=False, default=True,
    #     help="Update the exposure time in the JSON files."
    # )
    parser.add_argument("-u", "--update_data", action="store_true", help="Update the exposure time in the JSON files.")
    parser.add_argument("-nu", "--no-update_data", dest="update_data", action="store_false", help="Do not update the exposure time in the JSON files.")
    parser.set_defaults(update_data=True)
    parser.add_argument(
        "-b", "--vcr_booking_csv", type=str, required=False, default="",
        help="CSV booking file downloaded from the VCR. By default, will search for '*booking.csv' in --output_path"
    )
    parser.add_argument(
        "-o", "--output_path", type=str, required=True,
        help="Where every result / parset will be written."
    )
    parser.add_argument(
        "-n", "--max_repetitions", type=int, required=False, default=2,
        help="Maximum number of observations per target."
    )
    parser.add_argument("-m", "--merge_existing_booking", action="store_true", help="Merge with exisiting booking")
    parser.add_argument("-nm", "--no-merge_existing_booking", dest="merge_existing_booking", action="store_false", help="Do not merge with exisiting booking (default)")
    parser.set_defaults(merge_existing_booking=False)

    parser.add_argument("-e", "--only_existing_booking", action="store_true", help="Constrain the booking on existing slots")
    parser.add_argument("-ne", "--no-only_existing_booking", dest="only_existing_booking", action="store_false", help="Do not constrain the booking on existing slots (default)")
    parser.set_defaults(only_existing_booking=False)

    parser.add_argument(
        "-s", "--priority_source", nargs="*", required=False, default=[],
        help="Set these sources as priority targets"
    )
    parser.add_argument("-i", "--add_imaging", action="store_true", help="Add imaging observations.")
    parser.add_argument("-ni", "--no-add_imaging", dest="add_imaging", action="store_false", help="Do not add imaging observations.")
    parser.set_defaults(add_imaging=False)
    parser.add_argument(
        "-si", "--imaging_sources", nargs="*", required=False, default=[],
        help="Add these sources in imaging mode"
    )
    args = parser.parse_args()
    return args


# ============================================================= #
# --------------------------- main ---------------------------- #
if __name__ == "__main__":

    args = parse_arguments()

    # Check that the VCR booking file is defined or try to find it 
    if args.vcr_booking_csv == "":
        booking_file = glob.glob(os.path.join(args.output_path, "*_booking.csv"))
        if len(booking_file) != 1:
            log.error(f"Impossible to find the VCR booking file '*._booking.csv' in {args.output_path}.")
            raise FileNotFoundError("VCR booking file not found.")
        args.vcr_booking_csv = booking_file[0]
        log.info(f"Found booking file '{args.vcr_booking_csv}'.")

    # Read the source data
    exop = get_exoplanet_dict()
    star = get_star_dict()

    # Update the source data, i.e. their exposure time
    if args.update_data:
        log.info("Updating the data repositories, this may take a few minutes if this is not already cached...")
        log.info("Once it's done, you can shift+opt+f on a MacOS to make the JSON pretty ;)...")
        # exop = clear_exposure_time(exop)
        exop = update_exposure_time(exop, *DATA_REPOSITORIES, save=True)
        # star = clear_exposure_time(star)
        star = update_exposure_time(star, *DATA_REPOSITORIES, save=True)

        exop = update_minimal_elevation(exop, save=True)
        star = update_minimal_elevation(star, save=True)

    start_time = Time(args.time_min, format="isot")
    stop_time = Time(args.time_max, format="isot")
    prefix = f"{start_time.isot.split('T')[0]}_{stop_time.isot.split('T')[0]}_"

    # VCR booking
    booking_slots = bookings_from_vcr(
        vcr_current_booking=args.vcr_booking_csv,
        start_time=start_time,
        stop_time=stop_time,
        merge_slots=args.merge_existing_booking,
        only_kp_slots=args.only_existing_booking
    )

    # Add imaging data
    if args.add_imaging:
        imaging_sources = list(set(IMAGING_SOURCES + args.imaging_sources))

        imaging_source_dict = get_imaging_sources(
            all_sources={**exop, **star},
            imaging_sources=imaging_sources
        )

        # Define imaging observation blocks
        imaging_blocks = build_imaging_observation_blocks(
            source_dict=imaging_source_dict,
            source_list=imaging_sources,
            min_duration=IMAGING_MIN_DURATION
        )
        imaging_blocks *= args.max_repetitions

        # Schedule the LT2 imaging observations within the schedule
        scheduled_imaging_observations = book_observations(
            booking_starts_stops=booking_slots,
            source_dict=imaging_source_dict,
            observation_blocks=imaging_blocks,
            priority_sources=args.priority_source,
            release_duration=False # do not allow to shorten the minimal obs duration
        )

        plot_schedule(
            schedule=scheduled_imaging_observations,
            source_dict=imaging_source_dict,
            output_path=args.output_path,
            file_prefix=prefix + "imaging_"
        )

        imaging_results = scheduled_imaging_observations.export()
        imaging_observation_slots = [(obs["start"], obs["stop"]) for obs in imaging_results]

        # Update the available bookings
        booking_slots = booking_difference(booking_slots, imaging_observation_slots)

        for observation in imaging_results:
            write_parset_file(
                schedule_row=observation,
                source_dict=imaging_source_dict,
                output_path=args.output_path,
                file_prefix=prefix,
                add_imaging=True
            )
        
        del scheduled_imaging_observations
    else:
        imaging_observation_slots = []

    # Define observation blocks
    blocks = build_observation_blocks(exop)
    blocks += build_observation_blocks(star)
    blocks *= args.max_repetitions

    # Schedule the LT2 observations within the schedule
    scheduled_observations = book_observations(
        booking_starts_stops=booking_slots,
        source_dict={**exop, **star},
        observation_blocks=blocks,
        priority_sources=args.priority_source
    )

    plot_schedule(
        schedule=scheduled_observations,
        source_dict={**exop, **star},
        output_path=args.output_path,
        file_prefix=prefix
    )

    results = scheduled_observations.export()

    observation_slots = [(obs["start"], obs["stop"]) for obs in results]
    write_booking_file(
        booking_starts_stops=sorted(observation_slots + imaging_observation_slots),
        output_path=args.output_path,
        file_prefix=prefix
    )

    for observation in results:
        write_parset_file(
            schedule_row=observation,
            source_dict={**exop, **star},
            output_path=args.output_path,
            file_prefix=prefix
        )
# ============================================================= #
# ============================================================= #
