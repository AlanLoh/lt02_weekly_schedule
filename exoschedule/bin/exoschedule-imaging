#! /usr/bin/python3
# -*- coding: utf-8 -*-

"""
Example

    exoschedule-imaging -s ROSS_248 HD_189733 GJ_687 UPS_AND MCC_351 LP_355-051 YZ_CMI G_41-8 NLTT_20670 AD_LEO GJ_1134 BK_CrB HD_239960A EV_LAC EQ_PEG -t0 2025-10-28T00:00:00 -t1 2025-11-04T00:00:00 -n 2 -o /Users/aloh/Documents/Work/NenuFAR/LT02_Exoplanets/Weekly_Schedule/2025/2025-10-5_imaging/

"""

import argparse
from astropy.time import Time
import glob, os
import logging
log = logging.getLogger("exoschedule")

from exoschedule.functions import (
    bookings_from_vcr,
    write_booking_file,
    get_exoplanet_dict,
    get_star_dict
)
from exoschedule.schedule import (
    build_imaging_observation_blocks,
    book_observations,
    plot_schedule,
    write_parset_file
)
from exoschedule import DATA_REPOSITORIES, IMAGING_MIN_DURATION

# ============================================================= #
# ---------------------- argument_parser ---------------------- #
def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-s", "--sources", nargs="*", required=True,
        help="Sources to observe"
    )
    parser.add_argument(
        "-t0", "--time_min", type=str, required=True,
        help="Start time (UTC, ISOT format)."
    )
    parser.add_argument(
        "-t1", "--time_max", type=str, required=False,
        help="Stop time (UTC, ISOT format). If not user-defined, will be set to t0 + 7 days."
    )
    parser.add_argument(
        "-b", "--vcr_booking_csv", type=str, required=False, default="",
        help="CSV booking file downloaded from the VCR. By default, will search for '*booking.csv' in --output_path"
    )
    parser.add_argument(
        "-o", "--output_path", type=str, required=True,
        help="Where every result / parset will be written."
    )
    parser.add_argument(
        "-n", "--max_repetitions", type=int, required=False, default=2,
        help="Maximum number of observations per target."
    )
    parser.add_argument("-m", "--merge_existing_booking", action="store_true", help="Merge with exisiting booking")
    parser.add_argument("-nm", "--no-merge_existing_booking", dest="merge_existing_booking", action="store_false", help="Do not merge with exisiting booking (default)")
    parser.set_defaults(merge_existing_booking=False)
    parser.add_argument("-e", "--only_existing_booking", action="store_true", help="Constrain the booking on existing slots")
    parser.add_argument("-ne", "--no-only_existing_booking", dest="only_existing_booking", action="store_false", help="Do not constrain the booking on existing slots (default)")
    parser.set_defaults(only_existing_booking=False)
    args = parser.parse_args()
    return args


# ============================================================= #
# --------------------------- main ---------------------------- #
if __name__ == "__main__":

    args = parse_arguments()

    # Check that the VCR booking file is defined or try to find it 
    if args.vcr_booking_csv == "":
        booking_file = glob.glob(os.path.join(args.output_path, "*_booking.csv"))
        if len(booking_file) != 1:
            log.error(f"Impossible to find the VCR booking file '*._booking.csv' in {args.output_path}.")
            raise FileNotFoundError("VCR booking file not found.")
        args.vcr_booking_csv = booking_file[0]
        log.info(f"Found booking file '{args.vcr_booking_csv}'.")


    start_time = Time(args.time_min, format="isot")
    stop_time = Time(args.time_max, format="isot")
    prefix = f"{start_time.isot.split('T')[0]}_{stop_time.isot.split('T')[0]}_"

    # VCR booking
    booking_slots = bookings_from_vcr(
        vcr_current_booking=args.vcr_booking_csv,
        start_time=start_time,
        stop_time=stop_time,
        merge_slots=args.merge_existing_booking,
        only_kp_slots=args.only_existing_booking
    )

    # Read the source data
    exop = get_exoplanet_dict()
    star = get_star_dict()

    # Define observation blocks
    blocks = build_imaging_observation_blocks(
        source_dict={**exop, **star},
        source_list=args.sources,
        min_duration=IMAGING_MIN_DURATION
    )
    blocks *= args.max_repetitions

    # Schedule the LT2 observations within the schedule
    scheduled_observations = book_observations(
        booking_starts_stops=booking_slots,
        source_dict={**exop, **star},
        observation_blocks=blocks,
        priority_sources=args.sources,
        release_duration=False # do not allow to shorten the minimal obs duration
    )

    plot_schedule(
        schedule=scheduled_observations,
        source_dict={**exop, **star},
        output_path=args.output_path,
        file_prefix=prefix
    )

    results = scheduled_observations.export()

    observation_slots = [(obs["start"], obs["stop"]) for obs in results]
    write_booking_file(
        booking_starts_stops=observation_slots,
        output_path=args.output_path,
        file_prefix=prefix
    )

    for observation in results:
        write_parset_file(
            schedule_row=observation,
            source_dict={**exop, **star},
            output_path=args.output_path,
            file_prefix=prefix,
            add_imaging=True
        )
# ============================================================= #
# ============================================================= #
